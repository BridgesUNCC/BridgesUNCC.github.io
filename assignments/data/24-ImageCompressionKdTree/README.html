<p>Background:</p>

<p>This module will continue from Module and will continue to reinforce the object oriented concepts using the C++ language. Specifically, we will examine an object hierarchy in use at multiple institutions and use that to build a new class structure and apply it in an iapplication to represent images.</p>

<p>You should read  through the following materials in preparation for the activities in this module; a good bit of the material will be very similar to Java, except the I/O.</p>

<pre><code>Review: Preparation section of Module 5, relating to inheritance, polymorphism, access control (public/private sections of classes).
Bridges object hierarchy:  The complete BRIDGES object hierarchy can be found at  at this link (Links to an external site.). In this module we are interested in  the  hierarchy that implements tree structures.
    Bridges Tree Hierarchy. (Links to an external site.) This set of classes implement generalized trees, binary trees, binary search trees,  and AVL trees.
    Review first the documentation of these classes; clicking on any of the classes in the class diagram at this link will take you to its class documentation.
    Review also the source code  for each of the classes at this github site (Links to an external site.).
    In particular, you should understand the design of each of these classes, public/private sections, what each subclass adds to the superclass and the reasoning behind the design of this hierarchy.  In addition, look for virtual functions in the classes and why they need to be virtual functions.
K-D Trees: K-D trees (K stands for the dimension) are a spatial equivalent  of the more familiar binary search trees (that usually have integer keys to facililtate efficient (log n) search),  and belong to the class of spatial search  tree structures, that include quadtrees, octrees. In a 2D K-D tree (K = 2), we start with a 2D square region and each step divides the space up into 2 regions using a partitioning line, that is usually axis-aligned  (horizontal or vertical).  This is done recursively, i.e., the subdivided regions are further subdivided until a certain termination criterion is reached. See the following figure that illustrates a 3 level partitioning:


kdt-3-level.png

kdt-3-level-tree.pngFig.1: (Top)  Illustrates a K-D tree partitioning applied to a 2D region. In this case, the partitioning orientation alternates between horizontal and vertical, and the partitioning stops based on a termination criterion, (Bottom) The tree structure generated by the algorithm


In the figure above, a 2D region is being partitioned. The first partitioner is the white line that goes across the region, dividing it into two subregions (these become children of the root node of the tree. At the next level, the yellow lines partition the two subregions creating two of their own children each. Finally the blue lines subdivide at the third level. Each region can contain data (di s) that can be  points or other information that can then be searched for efficiently knowing the location of the partitioning lines.
Representing Images with K-D Trees:
A Green square in a blue image
K-D Tree Representaion of Image
Fig. 2:   Application of K-D Trees to representing a shape. Here the green square (top image)  is a simple shape being approximated by a 2D  K-D tree representation. Note the adaptive partitioning, i.e., only regions near the cube boundary are partitioned, while the homogeneous (large blue) (or the interior cube) regions are not. Regions that are homogeneous are not partitioned and become leaf  nodes of the tree.

See the above image that contains a small green square inside a blue background.  The top image is the original image and the bottom is a K-d Tree representation of the same image. The white lines in the bottom image represent the partitioning lines. Notice that this representation  is approximate, since the image itself is represented by the leaf nodes (which are all rectangles of varying size) of the tree. In other words, the K-D tree chops up the original image rectangle into a set of  smaller sized rectangular regions  to represent the image.  The entire image is now  the tree with enough information (leaf nodes will have the region geometry and its color) to generate the image.
Applications: Refer to the Wikipedia page on K-D trees (Links to an external site.) for additional information  and applications.
</code></pre>

<p>Project:</p>

<p>In this project, you will develop a K-D TreeElement class structure as a subclass of the BinTreeElement defined in BRIDGES. You will use this structure along with the ColorGrid type (that you used in earlier modules) to represent images using K-D Trees.</p>

<p>Relevant Concepts/Sections:  Refer to the Preparation section to get ready for the tasks in this module.</p>

<p>Tasks/Requirements</p>

<pre><code>[Milestone 1] KdTreeElement Class Design/Familiarity: Study KdTreeElement (Links to an external site.) class that implements a node of the KdTree.  You will do the following 2 tasks to get comfortable using the Kd Tree element
    Build and run the example in the Kd Tree tutorial (Links to an external site.) to generate the visualization shown at the bottom of that page.
    The tutorial example hard codes the element to create the tree. Write an insertKdTree() function that takes 10 values  and inserts it into the tree (this is exactly like a  binary search tree insert algorithm to find the insertion point and then place the value at the right leaf node:

    KdTreeElement&lt;int, int&gt;  *insertKdTree (int *values, int count)
[Milestone 2]Representing Images using the Kd Tree. We will use the ColorGrid structure in BRIDGES to hold an image (Review the colorgrid examples and projects from earlier modules). Sample images will be provided. The general idea  of representing images using a spatial structure is to  subdivide the image region adaptively, i.e., focusing higher amounts of subdivision in areas of more detail/complexity. so as to get a more accurate representation.  You will develop this application in two stages:
    Partition the region and display the partitioning lines
    Develop tests for homogeneity of a region and use that to terminate the subdivision or if the region becomes smaller than a fixed size.
Output: Your application will display (using BRIDGES) both the  original images and the KD tree representation of the image (including the partitioning lines). In addition to the normal turnin to the submission page, you will also post the images you generated to the Discussion forum.
Modularity/Documentation: Your program should be modular and should use functions to accomplish each task. For documentation, take a look at the link (Links to an external site.) provided in the Reading Materials section of the module. Each function should be documented and function and variable names should be meaningful and use properly indented code.
</code></pre>

<p>PseudoCode for K-D Tree Representation of Image:</p>

<p>KdTreeElement<int, string> *buildImageTree (
        int *region,    // region - xmin, ymin, xmax, ymax
        int level,      // level of the tree, starts at 0 for root
        ColorGrid *cg   // the region - originally the entire image
        bool dim_flag)  // partitioning dimension, will flip with each
                                        //  level
                            {
        // create a kd tree element 
    KdTreeElement<int, int> *root = new KdTreeElement<int, int>(.....)</p>

<pre><code>    // check the region's homogeneity
bool homogeneous = IsRegionHomogeneous(....);

if ((level &lt; MaxLevel) &amp;&amp; !homogeneous) {   // partition 
    if (!dim_flag){     // partition on X
                        // choose a partioning value between xmin and xmax
        partition = partition(.... )
                        // form the two partitioned regions, left and right
        int lregion[] = ...
        int rregion[] = ...
                        // recurse
        root-&gt;setLeft(buildImageTree (.....);
        root-&gt;setRight(buildImageTree (.....);
    }
    else {              // partition on Y
        // ditto... for partitioning on the Y dimension, similar to X but regions
        // will be bottom and top regions

    }
                    // color the partitioning line, in white, so
                    // we can see the adaptive kd tree partitioning of 
                    // the image first form the partitioned region, 
                    // depending on the partitioning dimension      
                    // treat it as a thin region of width 2 or 3 pixels, so
                    // its clearly visible
    int partitioned_region[] = {.....}

                    // color the region - similar to the color grid in Module 1
    ColorRegion ( ......, "white"...)

    return root;
}

                        // region is homogeenous, color it using the average
                        // color of the region (compute avg in r, g, b separately
ColorRegion (cg, region);

return nullptr;
</code></pre>

<p>}</p>

<p>Region Homogeneity:</p>

<p>We need to be able to compute how homogeneous a region is before
deciding to to partition that region. You will write two versions of this function</p>

<p>IsRegionHomogeneous ()</p>

<p>which takes in  a region (which is a box within the image) and checks to see if the colors are homogeneous within a threshold;</p>

<p>The first version will work on only 2 color images, while the second version will work on multicolor images. In the simpler version, you simply have to see if there are two pixels of different colors to determine a region to be not homogeneous, else it is homogeneous</p>

<p>The second version will use the following algorithm: first sum the colors (for each of the red, green and blue components) and compute the average red, blue and green colors for the regoin. Next iterate through the region's pixels and compare each R, G, B value to the average. If any of the differences are above a threshold (say 5 or 10), then the region is not homogeneous and return false, else return true.</p>

<p>Max levels:</p>

<p>Notice that there is a constant called Max_Levels - this is used to limit amount of partitioning (height of the KD tree). The level variable should be incremented when you recurse and the recursion will terminate if the max levels is reached.</p>

<p>Partitioner:</p>

<p>Write a function that will return a partitioning value between the region's min and max values in that dimension. For instance, the region's X values are within  10  to 50, then pick a value between the two at random; to avoid very thin regions, pick a value between first and the second third (between (10+40/3,  50-40/3).  If the region width (max-min)  is less than  3, then return true (homogeneous) to avoid degenerate cases).</p>

<p>Visualization:</p>

<p>Note that we are using the ColorGrid type to fill the
image with the region colors, so that we can visualize it with BRIDGES. Again, refer to earlier modules on the use of the ColorGrid.</p>

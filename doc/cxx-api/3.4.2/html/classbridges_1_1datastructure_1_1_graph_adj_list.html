<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bridges-C++: bridges::datastructure::GraphAdjList&lt; K, E1, E2 &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Bridges-C++
   &#160;<span id="projectnumber">3.4.2</span>
   </div>
   <div id="projectbrief">Bridges(C++ API)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebridges.html">bridges</a></li><li class="navelem"><a class="el" href="namespacebridges_1_1datastructure.html">datastructure</a></li><li class="navelem"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">GraphAdjList</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classbridges_1_1datastructure_1_1_graph_adj_list-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">bridges::datastructure::GraphAdjList&lt; K, E1, E2 &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_graph_adj_list_8h_source.html">GraphAdjList.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for bridges::datastructure::GraphAdjList&lt; K, E1, E2 &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbridges_1_1datastructure_1_1_graph_adj_list.png" usemap="#bridges::datastructure::GraphAdjList_3C_20K_2C_20E1_2C_20E2_20_3E_map" alt=""/>
  <map id="bridges::datastructure::GraphAdjList_3C_20K_2C_20E1_2C_20E2_20_3E_map" name="bridges::datastructure::GraphAdjList_3C_20K_2C_20E1_2C_20E2_20_3E_map">
<area href="classbridges_1_1datastructure_1_1_data_structure.html" title="This is the superclass of all data structure types in BRIDGES." alt="bridges::datastructure::DataStructure" shape="rect" coords="0,0,293,24"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename K, typename E1 = K, typename E2 = E1&gt;<br />
class bridges::datastructure::GraphAdjList&lt; K, E1, E2 &gt;</h3>

<p>This class provides methods to represent adjacency list based graphs. </p>
<pre class="fragment">The GraphAdjList class can be used to represent adjacency list
</pre><p> based graphs in BRIDGES; it takes 3 generic parameters: (1) K, which is an orderable key value used in accessing vertices (in constant time) using an STL map. This permits data sets that need to be accessed by keys that are strings, (2) E1, for maintaining vertex specific data, and (3) E2, for maintaining edge specific data. The class is a wrapper around the C++ unordered map class and, thus, derives all its operations from it. BRIDGES provides methods to visualize the graph and its contents.</p>
<p>The vertices of the graph are held in a C++ hashmap, for near constant time access; this enables us to use strings or integer ids for vertices. The adjacency lists are linked lists of SLelemnt type, The <a class="el" href="classbridges_1_1datastructure_1_1_s_lelement.html" title="The singly linked list element, derived from Element.">SLelement</a> contains edge information (stored in its data as a generic). Each edge, of type <a class="el" href="classbridges_1_1datastructure_1_1_edge.html" title="This helper class is used by the graph classes - GraphAdjList , GraphAdjMatrix - to keep track of edg...">Edge</a>, contains the source, destination vertices and link attributes (color, opacity, thickness)</p>
<p>Convenience method <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#a3bde76e49be4330da895103475f8430b" title="Adds a vertex to the graph.">addVertex()</a> is provided to add vertices to the graph, and <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#a6573cc104657315196404bcef481d890">addEdge()</a> is provided to add edges. Edges are retrieved by using the map and the adjcency list, given the vertex ids of the edge. Vertices can be styled directly from the vertex element returned by <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#ada58af550495cee2fe454c0be0f8504e" title="Return the vertex corresponding to a key.">getVertex()</a>, and edges are styled from a <a class="el" href="classbridges_1_1datastructure_1_1_link_visualizer.html" title="This class maintains the visual properties of links within data structures.">LinkVisualizer</a> one can access through <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#ae36ba10fae403339df0c36707ed13536" title="Returns the link visualizer corresponding to an edge. Returns the link visualizer corresponding to tw...">getLinkVisualizer()</a>. Here is a simple example: </p><div class="fragment"><div class="line">GraphAdjList&lt;string, Integer, Double&gt; graph = <span class="keyword">new</span> GraphAdjList&lt;string, int, double&gt; ();</div>
<div class="line">  graph.addVertex(<span class="stringliteral">&quot;a&quot;</span>);</div>
<div class="line">  graph.addVertex(<span class="stringliteral">&quot;b&quot;</span>);</div>
<div class="line">  graph.addEdge(<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>);</div>
<div class="line">  graph.getVertex(<span class="stringliteral">&quot;a&quot;</span>).setShape(<span class="stringliteral">&quot;square&quot;</span>);</div>
<div class="line">  graph.getLinkVisualizer(<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>).setColor(<span class="stringliteral">&quot;yellow&quot;</span>);</div>
</div><!-- fragment --><p>Adjacency lists are singly linked lists using the BRIDGES <a class="el" href="classbridges_1_1datastructure_1_1_s_lelement.html" title="The singly linked list element, derived from Element.">SLelement</a>. Iterators are provided for easy traversal of the adjacency lists. For instance,</p>
<div class="fragment"><div class="line">GraphAdjList&lt;string, int, double&gt; graph = something();</div>
<div class="line"><span class="keywordflow">for</span> (Edge&lt;string, double&gt; e : graph.outgoingEdgeSetOf(<span class="stringliteral">&quot;a&quot;</span>))</div>
<div class="line">  System.out.println(<span class="stringliteral">&quot;a -&gt; &quot;</span>+<a class="code" href="namespacebridges_1_1game.html#ab9a19c7ab6e2ebac2f95180e21733487ae1671797c52e15f763380b45e841ec32">e</a>.getTo());</div>
<div class="ttc" id="anamespacebridges_1_1game_html_ab9a19c7ab6e2ebac2f95180e21733487ae1671797c52e15f763380b45e841ec32"><div class="ttname"><a href="namespacebridges_1_1game.html#ab9a19c7ab6e2ebac2f95180e21733487ae1671797c52e15f763380b45e841ec32">bridges::game::NamedSymbol::e</a></div><div class="ttdeci">@ e</div></div>
</div><!-- fragment --><p>Graphs can have their nodes and links affected by visual attributes. Nodes can have color, size, opacity and shape and detailed in the <a class="el" href="classbridges_1_1datastructure_1_1_element_visualizer.html" title="This class maintains the visual properties of the a Bridges element.">ElementVisualizer</a> class. Edges support attributes such as color, thickness and opacity and are detailed in the <a class="el" href="classbridges_1_1datastructure_1_1_link_visualizer.html" title="This class maintains the visual properties of links within data structures.">LinkVisualizer</a> class. <a class="el" href="classbridges_1_1datastructure_1_1_element.html" title="This is the fundamental building block for all data structures in BRIDGES.">Element</a> and link attributes are set using the <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#a097e4678b1273c29b1ac63319b4535e5" title="Returns the visualizer corresponding to a graph vertex. convenient method to set attributes of the gr...">getVisualizer()</a> and <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#ae36ba10fae403339df0c36707ed13536" title="Returns the link visualizer corresponding to an edge. Returns the link visualizer corresponding to tw...">getLinkVisualizer()</a> methods. For instance,</p>
<div class="fragment"><div class="line">GraphAdjList&lt;string, int, double&gt; graph = something();</div>
<div class="line">  graph.addVertex(<span class="stringliteral">&quot;baskin&quot;</span>);</div>
<div class="line">  graph.addVertex(<span class="stringliteral">&quot;robins&quot;</span>);</div>
<div class="line">  graph.addEdge(<span class="stringliteral">&quot;baskin&quot;</span>,<span class="stringliteral">&quot;robins&quot;</span>);</div>
<div class="line">  graph.getVisualizer()-&gt;setColor(<span class="stringliteral">&quot;cyan&quot;</span>);</div>
<div class="line">  graph.getVisualizer()-&gt;setShape(<span class="stringliteral">&quot;square&quot;</span>);</div>
<div class="line">  graph.getLinkVisualizer(<span class="stringliteral">&quot;baskin&quot;</span>, <span class="stringliteral">&quot;robins&quot;</span>)-&gt;setColor(<span class="stringliteral">&quot;green&quot;</span>);</div>
<div class="line">  graph.getLinkVisualizer(<span class="stringliteral">&quot;baskin&quot;</span>, <span class="stringliteral">&quot;robins&quot;</span>)-&gt;setOpacity(<span class="stringliteral">&quot;0.5f&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">K</td><td>used as an index to retrieve vertices, </td></tr>
    <tr><td class="paramname">E1</td><td>data type used to store vertex specific information, </td></tr>
    <tr><td class="paramname">E2</td><td>data type used to store edge specific information</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Kalpathi Subramanian, Erik Saule </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Last modified 4/22/18, 7/12/19, 12/28/20, 1/5/21</dd></dl>
<p>There is a tutorial about Graph Adjacency List : <a href="https://bridgesuncc.github.io/tutorials/Graph.html">https://bridgesuncc.github.io/tutorials/Graph.html</a></p>
<p>There are two visualization engines available for graph. The small graph visualization supports all attributes of vertices and edges but is prohibitively slow on large graphs. The large graph visualization only supports locations (actually they are mandatory) and colors, all other attributes are ignored.</p>
<p>BRIDGES picks the rendering engine automatically. But it can be forced to pick one used forceLargeVizualization() and forceSmallVizualization() </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list_1_1const_vertex_element_set__listhelper.html">constVertexElementSet_listhelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a helper class to return sets of vertices in a way that are iterable with range for loops. Students should not have to use this directly.  <a href="classbridges_1_1datastructure_1_1_graph_adj_list_1_1const_vertex_element_set__listhelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list_1_1_key_set__helper.html">KeySet_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list_1_1_vertex_element_set__listhelper.html">VertexElementSet_listhelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a helper class to return sets of vertices in a way that are iterable with range for loops. Students should have to use this directly.  <a href="classbridges_1_1datastructure_1_1_graph_adj_list_1_1_vertex_element_set__listhelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adb181bcfe104b8df8b3218ccf1b67ea5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#adb181bcfe104b8df8b3218ccf1b67ea5">GraphAdjList</a> ()=default</td></tr>
<tr class="separator:adb181bcfe104b8df8b3218ccf1b67ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac175167a4447f3fc9c7f3e72f2f6a0b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#ac175167a4447f3fc9c7f3e72f2f6a0b1">GraphAdjList</a> (<a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">GraphAdjList</a> &amp;&amp;gr)=default</td></tr>
<tr class="separator:ac175167a4447f3fc9c7f3e72f2f6a0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17413dc27d7e60e1aa31cafa32082d12"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#a17413dc27d7e60e1aa31cafa32082d12">~GraphAdjList</a> () override</td></tr>
<tr class="separator:a17413dc27d7e60e1aa31cafa32082d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1bfde5ec7192f3ee334695059f8fa6"><td class="memItemLeft" align="right" valign="top">virtual const string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#adf1bfde5ec7192f3ee334695059f8fa6">getDStype</a> () const override</td></tr>
<tr class="memdesc:adf1bfde5ec7192f3ee334695059f8fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string representation of this data structure type.  <a href="classbridges_1_1datastructure_1_1_graph_adj_list.html#adf1bfde5ec7192f3ee334695059f8fa6">More...</a><br /></td></tr>
<tr class="separator:adf1bfde5ec7192f3ee334695059f8fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bde76e49be4330da895103475f8430b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#a3bde76e49be4330da895103475f8430b">addVertex</a> (const K &amp;k, const E1 &amp;e=E1())</td></tr>
<tr class="memdesc:a3bde76e49be4330da895103475f8430b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a vertex to the graph.  <a href="classbridges_1_1datastructure_1_1_graph_adj_list.html#a3bde76e49be4330da895103475f8430b">More...</a><br /></td></tr>
<tr class="separator:a3bde76e49be4330da895103475f8430b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6573cc104657315196404bcef481d890"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#a6573cc104657315196404bcef481d890">addEdge</a> (const K &amp;src, const K &amp;dest, const E2 &amp;data=E2())</td></tr>
<tr class="separator:a6573cc104657315196404bcef481d890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926702012e62a91affc14b62802724e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#a926702012e62a91affc14b62802724e4">isEdge</a> (const K &amp;src, const K &amp;dest)</td></tr>
<tr class="separator:a926702012e62a91affc14b62802724e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9d3875e7f6eb0d4c3500c53957b9c1"><td class="memItemLeft" align="right" valign="top">const E1 &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#a3a9d3875e7f6eb0d4c3500c53957b9c1">getVertexData</a> (const K &amp;src) &amp;</td></tr>
<tr class="memdesc:a3a9d3875e7f6eb0d4c3500c53957b9c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets vertex data for a graph vertex.  <a href="classbridges_1_1datastructure_1_1_graph_adj_list.html#a3a9d3875e7f6eb0d4c3500c53957b9c1">More...</a><br /></td></tr>
<tr class="separator:a3a9d3875e7f6eb0d4c3500c53957b9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87a30e6cbaf1d2db95dce705ebdd20f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#ab87a30e6cbaf1d2db95dce705ebdd20f">setVertexData</a> (const K &amp;vertID, E1 const &amp;data)</td></tr>
<tr class="memdesc:ab87a30e6cbaf1d2db95dce705ebdd20f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads vertex specific information for a graph vertex.  <a href="classbridges_1_1datastructure_1_1_graph_adj_list.html#ab87a30e6cbaf1d2db95dce705ebdd20f">More...</a><br /></td></tr>
<tr class="separator:ab87a30e6cbaf1d2db95dce705ebdd20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56ec428deb9a5bc4499f42bbd710b1a"><td class="memItemLeft" align="right" valign="top">E2 &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#ab56ec428deb9a5bc4499f42bbd710b1a">getEdgeData</a> (const K &amp;src, const K &amp;dest)</td></tr>
<tr class="memdesc:ab56ec428deb9a5bc4499f42bbd710b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets edge data for the edge from "src" to "dest".  <a href="classbridges_1_1datastructure_1_1_graph_adj_list.html#ab56ec428deb9a5bc4499f42bbd710b1a">More...</a><br /></td></tr>
<tr class="separator:ab56ec428deb9a5bc4499f42bbd710b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2cdffda7c983c3141ae36acc2b698d"><td class="memItemLeft" align="right" valign="top">E2 const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#a5c2cdffda7c983c3141ae36acc2b698d">getEdgeData</a> (const K &amp;src, const K &amp;dest) const</td></tr>
<tr class="memdesc:a5c2cdffda7c983c3141ae36acc2b698d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets edge data for the edge from "src" to "dest" - const version.  <a href="classbridges_1_1datastructure_1_1_graph_adj_list.html#a5c2cdffda7c983c3141ae36acc2b698d">More...</a><br /></td></tr>
<tr class="separator:a5c2cdffda7c983c3141ae36acc2b698d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a7e957d60e18b540dc778b1d569372"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#a21a7e957d60e18b540dc778b1d569372">setEdgeData</a> (const K &amp;src, const K &amp;dest, E2 &amp;data)</td></tr>
<tr class="memdesc:a21a7e957d60e18b540dc778b1d569372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads edge specific information for the edge from "src" to "dest".  <a href="classbridges_1_1datastructure_1_1_graph_adj_list.html#a21a7e957d60e18b540dc778b1d569372">More...</a><br /></td></tr>
<tr class="separator:a21a7e957d60e18b540dc778b1d569372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91334de325f4be241c3c939ea9c5a36"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; K, <a class="el" href="classbridges_1_1datastructure_1_1_element.html">Element</a>&lt; E1 &gt; * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#af91334de325f4be241c3c939ea9c5a36">getVertices</a> ()</td></tr>
<tr class="memdesc:af91334de325f4be241c3c939ea9c5a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the graph nodes.  <a href="classbridges_1_1datastructure_1_1_graph_adj_list.html#af91334de325f4be241c3c939ea9c5a36">More...</a><br /></td></tr>
<tr class="separator:af91334de325f4be241c3c939ea9c5a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b21cfdb87c4cf45ce29be6e7dd9791"><td class="memItemLeft" align="right" valign="top">const unordered_map&lt; K, <a class="el" href="classbridges_1_1datastructure_1_1_element.html">Element</a>&lt; E1 &gt; * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#a77b21cfdb87c4cf45ce29be6e7dd9791">getVertices</a> () const</td></tr>
<tr class="memdesc:a77b21cfdb87c4cf45ce29be6e7dd9791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the graph nodes - const version.  <a href="classbridges_1_1datastructure_1_1_graph_adj_list.html#a77b21cfdb87c4cf45ce29be6e7dd9791">More...</a><br /></td></tr>
<tr class="separator:a77b21cfdb87c4cf45ce29be6e7dd9791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada58af550495cee2fe454c0be0f8504e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbridges_1_1datastructure_1_1_element.html">Element</a>&lt; E1 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#ada58af550495cee2fe454c0be0f8504e">getVertex</a> (const K &amp;key) const</td></tr>
<tr class="memdesc:ada58af550495cee2fe454c0be0f8504e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vertex corresponding to a key.  <a href="classbridges_1_1datastructure_1_1_graph_adj_list.html#ada58af550495cee2fe454c0be0f8504e">More...</a><br /></td></tr>
<tr class="separator:ada58af550495cee2fe454c0be0f8504e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55482a035e233299d49874732113e6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbridges_1_1datastructure_1_1_element.html">Element</a>&lt; E1 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#aa55482a035e233299d49874732113e6d">getVertex</a> (const K &amp;key)</td></tr>
<tr class="separator:aa55482a035e233299d49874732113e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8ff5a971516d05ff07bb1c3b73e405"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbridges_1_1datastructure_1_1_edge.html">Edge</a>&lt; K, E2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#a2d8ff5a971516d05ff07bb1c3b73e405">getEdge</a> (const K &amp;src, const K &amp;dest)</td></tr>
<tr class="memdesc:a2d8ff5a971516d05ff07bb1c3b73e405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the edge between src and dest vertices.  <a href="classbridges_1_1datastructure_1_1_graph_adj_list.html#a2d8ff5a971516d05ff07bb1c3b73e405">More...</a><br /></td></tr>
<tr class="separator:a2d8ff5a971516d05ff07bb1c3b73e405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23dad50371f073dd9a2f48e83720e86c"><td class="memItemLeft" align="right" valign="top">const unordered_map&lt; K, <a class="el" href="classbridges_1_1datastructure_1_1_s_lelement.html">SLelement</a>&lt; <a class="el" href="classbridges_1_1datastructure_1_1_edge.html">Edge</a>&lt; K, E2 &gt; &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#a23dad50371f073dd9a2f48e83720e86c">getAdjacencyList</a> () const</td></tr>
<tr class="memdesc:a23dad50371f073dd9a2f48e83720e86c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the adjacency list.  <a href="classbridges_1_1datastructure_1_1_graph_adj_list.html#a23dad50371f073dd9a2f48e83720e86c">More...</a><br /></td></tr>
<tr class="separator:a23dad50371f073dd9a2f48e83720e86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3df7d161ed7847a188b5818f78818d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbridges_1_1datastructure_1_1_s_lelement.html">SLelement</a>&lt; <a class="el" href="classbridges_1_1datastructure_1_1_edge.html">Edge</a>&lt; K, E2 &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#aa3df7d161ed7847a188b5818f78818d8">getAdjacencyList</a> (const K &amp;k)</td></tr>
<tr class="memdesc:aa3df7d161ed7847a188b5818f78818d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns adjacency list of a vertex with name k.  <a href="classbridges_1_1datastructure_1_1_graph_adj_list.html#aa3df7d161ed7847a188b5818f78818d8">More...</a><br /></td></tr>
<tr class="separator:aa3df7d161ed7847a188b5818f78818d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8ea98a84017aa4bf6058475c0b3ed0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbridges_1_1datastructure_1_1_s_lelement.html">SLelement</a>&lt; <a class="el" href="classbridges_1_1datastructure_1_1_edge.html">Edge</a>&lt; K, E2 &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#a1f8ea98a84017aa4bf6058475c0b3ed0">getAdjacencyList</a> (const K &amp;k) const</td></tr>
<tr class="separator:a1f8ea98a84017aa4bf6058475c0b3ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097e4678b1273c29b1ac63319b4535e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbridges_1_1datastructure_1_1_element_visualizer.html">ElementVisualizer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#a097e4678b1273c29b1ac63319b4535e5">getVisualizer</a> (const K &amp;k)</td></tr>
<tr class="memdesc:a097e4678b1273c29b1ac63319b4535e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the visualizer corresponding to a graph vertex. convenient method to set attributes of the graph vertex.  <a href="classbridges_1_1datastructure_1_1_graph_adj_list.html#a097e4678b1273c29b1ac63319b4535e5">More...</a><br /></td></tr>
<tr class="separator:a097e4678b1273c29b1ac63319b4535e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36ba10fae403339df0c36707ed13536"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbridges_1_1datastructure_1_1_link_visualizer.html">LinkVisualizer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#ae36ba10fae403339df0c36707ed13536">getLinkVisualizer</a> (const K &amp;k1, const K &amp;k2)</td></tr>
<tr class="memdesc:ae36ba10fae403339df0c36707ed13536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the link visualizer corresponding to an edge. Returns the link visualizer corresponding to two graph nodes with an existing link; error returned if no link exists.  <a href="classbridges_1_1datastructure_1_1_graph_adj_list.html#ae36ba10fae403339df0c36707ed13536">More...</a><br /></td></tr>
<tr class="separator:ae36ba10fae403339df0c36707ed13536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6860a0a153fd126ebe8b1bc40d2753a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#a6860a0a153fd126ebe8b1bc40d2753a7">forceLargeVisualization</a> (bool f)</td></tr>
<tr class="memdesc:a6860a0a153fd126ebe8b1bc40d2753a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force the rendering engine to use large graph visualization.  <a href="classbridges_1_1datastructure_1_1_graph_adj_list.html#a6860a0a153fd126ebe8b1bc40d2753a7">More...</a><br /></td></tr>
<tr class="separator:a6860a0a153fd126ebe8b1bc40d2753a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9706e3df7d30320b7e7773a6423e4ff7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#a9706e3df7d30320b7e7773a6423e4ff7">forceSmallVisualization</a> (bool f)</td></tr>
<tr class="memdesc:a9706e3df7d30320b7e7773a6423e4ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force the rendering engine to use small graph visualization.  <a href="classbridges_1_1datastructure_1_1_graph_adj_list.html#a9706e3df7d30320b7e7773a6423e4ff7">More...</a><br /></td></tr>
<tr class="separator:a9706e3df7d30320b7e7773a6423e4ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0562e8d82499f26ad656a1dfb5f8908e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list_1_1_key_set__helper.html">KeySet_helper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#a0562e8d82499f26ad656a1dfb5f8908e">keySet</a> () const</td></tr>
<tr class="separator:a0562e8d82499f26ad656a1dfb5f8908e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac066da800ab88dc2e55a89650e08bb78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbridges_1_1datastructure_1_1_s_lelement.html">SLelement</a>&lt; <a class="el" href="classbridges_1_1datastructure_1_1_edge.html">Edge</a>&lt; K, E2 &gt; &gt;::SLelement_listhelper&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#ac066da800ab88dc2e55a89650e08bb78">outgoingEdgeSetOf</a> (K const &amp;k)</td></tr>
<tr class="memdesc:ac066da800ab88dc2e55a89650e08bb78"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is useful for iterating through a set of outgoing edges from a vertex.  <a href="classbridges_1_1datastructure_1_1_graph_adj_list.html#ac066da800ab88dc2e55a89650e08bb78">More...</a><br /></td></tr>
<tr class="separator:ac066da800ab88dc2e55a89650e08bb78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0677da029442194925f8167cc2b8638"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbridges_1_1datastructure_1_1_s_lelement.html">SLelement</a>&lt; <a class="el" href="classbridges_1_1datastructure_1_1_edge.html">Edge</a>&lt; K, E2 &gt; &gt;::SLelement_constlisthelper&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#ab0677da029442194925f8167cc2b8638">outgoingEdgeSetOf</a> (K const &amp;k) const</td></tr>
<tr class="memdesc:ab0677da029442194925f8167cc2b8638"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is useful for iterating through a set of outgoing edges from a vertex - const version.  <a href="classbridges_1_1datastructure_1_1_graph_adj_list.html#ab0677da029442194925f8167cc2b8638">More...</a><br /></td></tr>
<tr class="separator:ab0677da029442194925f8167cc2b8638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dcf0bb4a68f3b02281c84e9bb69d6b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list_1_1_vertex_element_set__listhelper.html">VertexElementSet_listhelper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#a9dcf0bb4a68f3b02281c84e9bb69d6b3">vertexSet</a> ()</td></tr>
<tr class="separator:a9dcf0bb4a68f3b02281c84e9bb69d6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef96f5df21b2f9743b7bb79c10cf090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list_1_1const_vertex_element_set__listhelper.html">constVertexElementSet_listhelper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html#a5ef96f5df21b2f9743b7bb79c10cf090">vertexSet</a> () const</td></tr>
<tr class="separator:a5ef96f5df21b2f9743b7bb79c10cf090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classbridges_1_1datastructure_1_1_data_structure"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classbridges_1_1datastructure_1_1_data_structure')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classbridges_1_1datastructure_1_1_data_structure.html">bridges::datastructure::DataStructure</a></td></tr>
<tr class="memitem:a54bde1c8f14ca3bff47910a2e48d586a inherit pub_methods_classbridges_1_1datastructure_1_1_data_structure"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbridges_1_1datastructure_1_1_data_structure.html#a54bde1c8f14ca3bff47910a2e48d586a">~DataStructure</a> ()=default</td></tr>
<tr class="separator:a54bde1c8f14ca3bff47910a2e48d586a inherit pub_methods_classbridges_1_1datastructure_1_1_data_structure"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adb181bcfe104b8df8b3218ccf1b67ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb181bcfe104b8df8b3218ccf1b67ea5">&#9670;&nbsp;</a></span>GraphAdjList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename E1  = K, typename E2  = E1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">bridges::datastructure::GraphAdjList</a>&lt; K, E1, E2 &gt;::<a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">GraphAdjList</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac175167a4447f3fc9c7f3e72f2f6a0b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac175167a4447f3fc9c7f3e72f2f6a0b1">&#9670;&nbsp;</a></span>GraphAdjList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename E1  = K, typename E2  = E1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">bridges::datastructure::GraphAdjList</a>&lt; K, E1, E2 &gt;::<a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">GraphAdjList</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">GraphAdjList</a>&lt; K, E1, E2 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>gr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a17413dc27d7e60e1aa31cafa32082d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17413dc27d7e60e1aa31cafa32082d12">&#9670;&nbsp;</a></span>~GraphAdjList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename E1  = K, typename E2  = E1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">bridges::datastructure::GraphAdjList</a>&lt; K, E1, E2 &gt;::~<a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">GraphAdjList</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6573cc104657315196404bcef481d890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6573cc104657315196404bcef481d890">&#9670;&nbsp;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename E1  = K, typename E2  = E1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">bridges::datastructure::GraphAdjList</a>&lt; K, E1, E2 &gt;::addEdge </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const E2 &amp;&#160;</td>
          <td class="paramname"><em>data</em> = <code>E2()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">@brief Add an edge with data.
</pre><p> Note that this function adds the edge regardless of the contents of the adjacency list; its the user's responsibility to ensure there are no duplicates and ensure consistency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The key of the source Vertex </td></tr>
    <tr><td class="paramname">dest</td><td>The key of the destination Vertex </td></tr>
    <tr><td class="paramname">data</td><td>The edge data </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out_of_range</td><td>If "src" or "dest" is non-existent within this graph </td></tr>
    <tr><td class="paramname">bad_alloc</td><td>If allocation of a graph adjacency list item failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3bde76e49be4330da895103475f8430b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bde76e49be4330da895103475f8430b">&#9670;&nbsp;</a></span>addVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename E1  = K, typename E2  = E1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">bridges::datastructure::GraphAdjList</a>&lt; K, E1, E2 &gt;::addVertex </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const E1 &amp;&#160;</td>
          <td class="paramname"><em>e</em> = <code>E1()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a vertex to the graph. </p>
<p>Adds a vertex of key "k" and value "e" to the graph, and initializes its adjacency list; If this key already exists then this will not create a new vertex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The vertex key </td></tr>
    <tr><td class="paramname">e</td><td>The vertex data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6860a0a153fd126ebe8b1bc40d2753a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6860a0a153fd126ebe8b1bc40d2753a7">&#9670;&nbsp;</a></span>forceLargeVisualization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename E1  = K, typename E2  = E1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">bridges::datastructure::GraphAdjList</a>&lt; K, E1, E2 &gt;::forceLargeVisualization </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force the rendering engine to use large graph visualization. </p>
<p>This forces the rendering to a more bandwidth efficient at the cost of having less features. The large graph visualization only renders vertices that have specified locations. The only usable attribute for vertices and edges are colors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>set to true to force the visualization engine to use large graphs visualization. Setting to false does not prevent large visualization to be used, just does not force it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9706e3df7d30320b7e7773a6423e4ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9706e3df7d30320b7e7773a6423e4ff7">&#9670;&nbsp;</a></span>forceSmallVisualization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename E1  = K, typename E2  = E1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">bridges::datastructure::GraphAdjList</a>&lt; K, E1, E2 &gt;::forceSmallVisualization </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force the rendering engine to use small graph visualization. </p>
<p>The small visualization uses more bandwidth, have more features, and support a force directed layout for vertices which do not have a specified location.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>set to true to force the visualization engine to use small graphs visualization. Setting to false does not prevent small visualization to be used, just does not force it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23dad50371f073dd9a2f48e83720e86c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23dad50371f073dd9a2f48e83720e86c">&#9670;&nbsp;</a></span>getAdjacencyList() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename E1  = K, typename E2  = E1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unordered_map&lt;K, <a class="el" href="classbridges_1_1datastructure_1_1_s_lelement.html">SLelement</a>&lt;<a class="el" href="classbridges_1_1datastructure_1_1_edge.html">Edge</a>&lt;K, E2&gt; &gt;*&gt;&amp; <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">bridges::datastructure::GraphAdjList</a>&lt; K, E1, E2 &gt;::getAdjacencyList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the adjacency list. </p>
<dl class="section return"><dt>Returns</dt><dd>The adjacency list of the graph </dd></dl>

</div>
</div>
<a id="aa3df7d161ed7847a188b5818f78818d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3df7d161ed7847a188b5818f78818d8">&#9670;&nbsp;</a></span>getAdjacencyList() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename E1  = K, typename E2  = E1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbridges_1_1datastructure_1_1_s_lelement.html">SLelement</a>&lt;<a class="el" href="classbridges_1_1datastructure_1_1_edge.html">Edge</a>&lt;K, E2&gt; &gt;* <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">bridges::datastructure::GraphAdjList</a>&lt; K, E1, E2 &gt;::getAdjacencyList </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns adjacency list of a vertex with name k. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key of the source vertex </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out_of_range</td><td>If key is non-existent within this graph</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The adjacency list of key "k" </dd></dl>

</div>
</div>
<a id="a1f8ea98a84017aa4bf6058475c0b3ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8ea98a84017aa4bf6058475c0b3ed0">&#9670;&nbsp;</a></span>getAdjacencyList() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename E1  = K, typename E2  = E1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbridges_1_1datastructure_1_1_s_lelement.html">SLelement</a>&lt;<a class="el" href="classbridges_1_1datastructure_1_1_edge.html">Edge</a>&lt;K, E2&gt; &gt;* <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">bridges::datastructure::GraphAdjList</a>&lt; K, E1, E2 &gt;::getAdjacencyList </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns adjacency list of a vertex with name k - const version</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key of the source vertex </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out_of_range</td><td>If key is non-existent within this graph</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The adjacency list of key "k" </dd></dl>

</div>
</div>
<a id="adf1bfde5ec7192f3ee334695059f8fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1bfde5ec7192f3ee334695059f8fa6">&#9670;&nbsp;</a></span>getDStype()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename E1  = K, typename E2  = E1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const string <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">bridges::datastructure::GraphAdjList</a>&lt; K, E1, E2 &gt;::getDStype </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the string representation of this data structure type. </p>
<dl class="section return"><dt>Returns</dt><dd>The string representation of this data structure type </dd></dl>

<p>Implements <a class="el" href="classbridges_1_1datastructure_1_1_data_structure.html#a4ff66cb34409f11fe9fc647f6d8a22ce">bridges::datastructure::DataStructure</a>.</p>

</div>
</div>
<a id="a2d8ff5a971516d05ff07bb1c3b73e405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d8ff5a971516d05ff07bb1c3b73e405">&#9670;&nbsp;</a></span>getEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename E1  = K, typename E2  = E1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbridges_1_1datastructure_1_1_edge.html">Edge</a>&lt;K, E2&gt; <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">bridges::datastructure::GraphAdjList</a>&lt; K, E1, E2 &gt;::getEdge </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the edge between src and dest vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source vertex of edge </td></tr>
    <tr><td class="paramname">dest</td><td>destination vertex of edge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>edge between the vertices </dd></dl>

</div>
</div>
<a id="ab56ec428deb9a5bc4499f42bbd710b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab56ec428deb9a5bc4499f42bbd710b1a">&#9670;&nbsp;</a></span>getEdgeData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename E1  = K, typename E2  = E1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">E2&amp; <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">bridges::datastructure::GraphAdjList</a>&lt; K, E1, E2 &gt;::getEdgeData </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets edge data for the edge from "src" to "dest". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The key of the source Vertex </td></tr>
    <tr><td class="paramname">dest</td><td>The key of the destination Vertex</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>edge specific data </dd></dl>

</div>
</div>
<a id="a5c2cdffda7c983c3141ae36acc2b698d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c2cdffda7c983c3141ae36acc2b698d">&#9670;&nbsp;</a></span>getEdgeData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename E1  = K, typename E2  = E1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">E2 const&amp; <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">bridges::datastructure::GraphAdjList</a>&lt; K, E1, E2 &gt;::getEdgeData </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets edge data for the edge from "src" to "dest" - const version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The key of the source Vertex </td></tr>
    <tr><td class="paramname">dest</td><td>The key of the destination Vertex</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>edge specific data </dd></dl>

</div>
</div>
<a id="ae36ba10fae403339df0c36707ed13536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae36ba10fae403339df0c36707ed13536">&#9670;&nbsp;</a></span>getLinkVisualizer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename E1  = K, typename E2  = E1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbridges_1_1datastructure_1_1_link_visualizer.html">LinkVisualizer</a>* <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">bridges::datastructure::GraphAdjList</a>&lt; K, E1, E2 &gt;::getLinkVisualizer </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>k1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>k2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the link visualizer corresponding to an edge. Returns the link visualizer corresponding to two graph nodes with an existing link; error returned if no link exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k1</td><td>The key of the link source vertex </td></tr>
    <tr><td class="paramname">k2</td><td>The key of the link destination vertex</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the visualizer that controls the attributes of this link </dd></dl>

</div>
</div>
<a id="aa55482a035e233299d49874732113e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55482a035e233299d49874732113e6d">&#9670;&nbsp;</a></span>getVertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename E1  = K, typename E2  = E1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbridges_1_1datastructure_1_1_element.html">Element</a>&lt;E1&gt;* <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">bridges::datastructure::GraphAdjList</a>&lt; K, E1, E2 &gt;::getVertex </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the requested vertex corresponding to a key - non-const version </p><dl class="section return"><dt>Returns</dt><dd>the requested vertex of this graph or nullptr if not found </dd></dl>

</div>
</div>
<a id="ada58af550495cee2fe454c0be0f8504e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada58af550495cee2fe454c0be0f8504e">&#9670;&nbsp;</a></span>getVertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename E1  = K, typename E2  = E1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbridges_1_1datastructure_1_1_element.html">Element</a>&lt;E1&gt;* <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">bridges::datastructure::GraphAdjList</a>&lt; K, E1, E2 &gt;::getVertex </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the vertex corresponding to a key. </p>
<dl class="section return"><dt>Returns</dt><dd>the requested vertex of this graph or nullptr if not found </dd></dl>

</div>
</div>
<a id="a3a9d3875e7f6eb0d4c3500c53957b9c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9d3875e7f6eb0d4c3500c53957b9c1">&#9670;&nbsp;</a></span>getVertexData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename E1  = K, typename E2  = E1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const E1&amp; <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">bridges::datastructure::GraphAdjList</a>&lt; K, E1, E2 &gt;::getVertexData </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets vertex data for a graph vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The key of the source vertex</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>E1 vertex specific data </dd></dl>

</div>
</div>
<a id="af91334de325f4be241c3c939ea9c5a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af91334de325f4be241c3c939ea9c5a36">&#9670;&nbsp;</a></span>getVertices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename E1  = K, typename E2  = E1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt;K, <a class="el" href="classbridges_1_1datastructure_1_1_element.html">Element</a>&lt;E1&gt;*&gt;* <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">bridges::datastructure::GraphAdjList</a>&lt; K, E1, E2 &gt;::getVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the graph nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>The vertex list of this graph </dd></dl>

</div>
</div>
<a id="a77b21cfdb87c4cf45ce29be6e7dd9791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b21cfdb87c4cf45ce29be6e7dd9791">&#9670;&nbsp;</a></span>getVertices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename E1  = K, typename E2  = E1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unordered_map&lt;K, <a class="el" href="classbridges_1_1datastructure_1_1_element.html">Element</a>&lt;E1&gt;*&gt;* <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">bridges::datastructure::GraphAdjList</a>&lt; K, E1, E2 &gt;::getVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the graph nodes - const version. </p>
<dl class="section return"><dt>Returns</dt><dd>The vertex list of this graph </dd></dl>

</div>
</div>
<a id="a097e4678b1273c29b1ac63319b4535e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a097e4678b1273c29b1ac63319b4535e5">&#9670;&nbsp;</a></span>getVisualizer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename E1  = K, typename E2  = E1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbridges_1_1datastructure_1_1_element_visualizer.html">ElementVisualizer</a>* <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">bridges::datastructure::GraphAdjList</a>&lt; K, E1, E2 &gt;::getVisualizer </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the visualizer corresponding to a graph vertex. convenient method to set attributes of the graph vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key of the graph vertex</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the visualizer that controls the attributes of this node </dd></dl>

</div>
</div>
<a id="a926702012e62a91affc14b62802724e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926702012e62a91affc14b62802724e4">&#9670;&nbsp;</a></span>isEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename E1  = K, typename E2  = E1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">bridges::datastructure::GraphAdjList</a>&lt; K, E1, E2 &gt;::isEdge </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">@brief Check if there is an edge between the given vertices
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The key of the source Vertex </td></tr>
    <tr><td class="paramname">dest</td><td>The key of the destination Vertex </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0562e8d82499f26ad656a1dfb5f8908e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0562e8d82499f26ad656a1dfb5f8908e">&#9670;&nbsp;</a></span>keySet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename E1  = K, typename E2  = E1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list_1_1_key_set__helper.html">KeySet_helper</a> <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">bridges::datastructure::GraphAdjList</a>&lt; K, E1, E2 &gt;::keySet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a set of all keys (helper function).</p>
<p>Returns a set of all keys (read only) that conforms to STL list interface. That means we can use range for loops on graph vertices.</p>
<dl class="section return"><dt>Returns</dt><dd>set all keys </dd></dl>

</div>
</div>
<a id="ac066da800ab88dc2e55a89650e08bb78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac066da800ab88dc2e55a89650e08bb78">&#9670;&nbsp;</a></span>outgoingEdgeSetOf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename E1  = K, typename E2  = E1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbridges_1_1datastructure_1_1_s_lelement.html">SLelement</a>&lt;<a class="el" href="classbridges_1_1datastructure_1_1_edge.html">Edge</a>&lt;K, E2&gt; &gt;::SLelement_listhelper <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">bridges::datastructure::GraphAdjList</a>&lt; K, E1, E2 &gt;::outgoingEdgeSetOf </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is useful for iterating through a set of outgoing edges from a vertex. </p>

</div>
</div>
<a id="ab0677da029442194925f8167cc2b8638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0677da029442194925f8167cc2b8638">&#9670;&nbsp;</a></span>outgoingEdgeSetOf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename E1  = K, typename E2  = E1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbridges_1_1datastructure_1_1_s_lelement.html">SLelement</a>&lt;<a class="el" href="classbridges_1_1datastructure_1_1_edge.html">Edge</a>&lt;K, E2&gt; &gt;::SLelement_constlisthelper <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">bridges::datastructure::GraphAdjList</a>&lt; K, E1, E2 &gt;::outgoingEdgeSetOf </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is useful for iterating through a set of outgoing edges from a vertex - const version. </p>

</div>
</div>
<a id="a21a7e957d60e18b540dc778b1d569372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a7e957d60e18b540dc778b1d569372">&#9670;&nbsp;</a></span>setEdgeData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename E1  = K, typename E2  = E1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">bridges::datastructure::GraphAdjList</a>&lt; K, E1, E2 &gt;::setEdgeData </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E2 &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads edge specific information for the edge from "src" to "dest". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The key of the source Vertex </td></tr>
    <tr><td class="paramname">dest</td><td>The key of the destination Vertex </td></tr>
    <tr><td class="paramname">data</td><td>edge data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab87a30e6cbaf1d2db95dce705ebdd20f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab87a30e6cbaf1d2db95dce705ebdd20f">&#9670;&nbsp;</a></span>setVertexData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename E1  = K, typename E2  = E1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">bridges::datastructure::GraphAdjList</a>&lt; K, E1, E2 &gt;::setVertexData </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>vertID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E1 const &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads vertex specific information for a graph vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertID</td><td>The key of Vertex </td></tr>
    <tr><td class="paramname">data</td><td>data to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9dcf0bb4a68f3b02281c84e9bb69d6b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dcf0bb4a68f3b02281c84e9bb69d6b3">&#9670;&nbsp;</a></span>vertexSet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename E1  = K, typename E2  = E1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list_1_1_vertex_element_set__listhelper.html">VertexElementSet_listhelper</a> <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">bridges::datastructure::GraphAdjList</a>&lt; K, E1, E2 &gt;::vertexSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a set of vertices (Element&lt;E&gt;) that conforms to STL list interface. That means we can use range for </p>

</div>
</div>
<a id="a5ef96f5df21b2f9743b7bb79c10cf090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef96f5df21b2f9743b7bb79c10cf090">&#9670;&nbsp;</a></span>vertexSet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename E1  = K, typename E2  = E1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list_1_1const_vertex_element_set__listhelper.html">constVertexElementSet_listhelper</a> <a class="el" href="classbridges_1_1datastructure_1_1_graph_adj_list.html">bridges::datastructure::GraphAdjList</a>&lt; K, E1, E2 &gt;::vertexSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a set of vertices (Element&lt;E&gt;) that conforms to STL list interface. That means we can use range for </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/erik/work/bridges/bridges-cxx/src/<a class="el" href="_element_8h_source.html">Element.h</a></li>
<li>/home/erik/work/bridges/bridges-cxx/src/<a class="el" href="_graph_adj_list_8h_source.html">GraphAdjList.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jan 13 2023 18:24:12 for Bridges-C++ by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>

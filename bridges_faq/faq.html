<!DOCTYPE html>
<html>
<head>
<style>
.codeExample {
	color: blue;
	font-family: "Courier";
	padding-left: 20px;
}

.graphExample {
	font-family: "Courier";
	padding-left: 20px;
}

.codeComment {
	color: green;
	font-family: "Courier";
	padding-left: 20px;
}

.section {
	padding-bottom: 40px;
}
</style>
<meta charset="utf-8">
<title>Bridges FAQ</title>
</head>
<body style="max-width: 1000px">


	<div class="section">
		<h1>Getting Started</h1>
		See the <a href="http://bridgesuncc.github.io/main/Tutorial/">Hello World Tutorial</a>.
		<br><br>
		Or, see <a href="#GraphCode">What is the code to get started making a
			graph?<br></a> for more information on building graphs and connecting edges.
	</div>


	<div class="section">
		<h1>Element FAQ</h1>
		<a href="#element">What is an Element&lt;E&gt;?<br>
		</a> <a href="#generic">What is the &lt;E&gt;? <br></a> <a
			href="#SlElement">How does the SLelement&lt;E&gt; work?<br></a>
		<a href="#DlElement">How does the DLelement&lt;E&gt; work?<br></a>
		<a href="#TreeElement">How does the TreeElement&lt;E&gt; work?<br></a>
		<a href="#TreeVsDLE">How does a TreeElement&lt;E&gt; differ from a
			DLelement&lt;E&gt;?<br>
		</a> <a href="#ArrayElement">How does the ArrayElement&lt;E&gt; work?<br></a>
		<a href="#GraphElement">There is no GraphElement&lt;E&gt;. How is
			a graph represented?<br>
		</a> <a href="#GraphCode">What is the code to get started making a
			graph?<br>
		</a> <a href="#GraphMistake">Why are my graph edges connecting to
			vertices that I didn't assign?<br>
		</a> <a href="#GraphNotVisible">I've connected my graph edges, but the
			visualization doesn't show any nodes.<br>
		</a>

	</div>


	<div class="section">

		<h1>Bridges Visualization FAQ</h1>
		<a href="#BasicVisualize">How do I get Bridges to visualize?<br>
		</a> <a href="#SetDataStructure">What do I pass to setDataStructure()?<br></a>

		<a href="#Refresh">How do I refresh the visualization?<br></a> <a
			href="#VisualizeTiming">When should I call visualize()?<br></a>
		<a href="#TextVisualization">How do I change the text field on the
			Visualization?<br>
		</a> <a href="#NodeColor">How do I change the node color, size, or
			opacity on the Visualization?<br>
		</a> <a href="#Projects">How do I start a new visualization without
			overwriting the old one?<br>
		</a>
	</div>



	<div class="section">
		<h1>
			<a id="element">What is an Element&lt;E&gt;?</a>
		</h1>
		<p>
			Element&lt;E&gt; is the superclass of SLelement&lt;E&gt;,
			DLelement&lt;E&gt;, TreeElement&lt;E&gt;, and ArrayElement&lt;E&gt;.
			<br> <br> <img src="res/ClassStructure.png"
				style="max-width: 100%"> <br> <br> You will normally
			be using these classes to build data structures. Since they are
			subclasses of Element&lt;E&gt;, they inherit a common set of methods
			and instance variables, so to a certain extent they will share a
			common set of behavior. However, since they are all different
			classes, they will have methods and instance variables that are
			unique to their particular class.

		</p>
	</div>
	


	<div class="section">
		<h1>
			<a id="generic">What is the &lt;E&gt;?</a>
		</h1>
		<p>
			&lt;E&gt; is the Java generic parameter. It represents any class, so
			you can have an SLelement&lt;String&gt; or an
			SLelement&lt;Integer&gt; or any other class. <br> <br> You
			may be wondering, if &lt;E&gt; can be any class, then how does
			Element know how to behave since a Boolean does not have the same
			methods available as a String? <br> <br> Since we didn’t
			put any restrictions on &lt;E&gt; inside the Element class signature,
			we can only call methods of &lt;E&gt; that are common to ALL java
			objects. We will not be allowed to call a method on E that is
			particular to any one class. <br> <br> In this way, we can
			allow the Element&lt;E&gt; class to function as a container. The
			container doesn't care what it's holding, and whatever the container
			is holding doesn't influence the behavior of the container. <img
				src="res/Bucket.png" style="max-width: 100%">

		</p>
	</div>


	<div class="section">

		<h1>
			<a id="SlElement">How does the SLelement&lt;E&gt; work?</a>
		</h1>
		<p>
			SLelement&lt;E&gt; stands for Singly Linked Element and is a type of
			container that only has one pointer which points to another
			SLelement&lt;E&gt;. So an SLelement&lt;E&gt; "knows" who it's
			pointing at but it does not know who pointed at it. <br> <br>
			<img src="res/SLelement.png" style="max-width: 100%"> <br>
			<br> In this case SLelement1 points to SLelement2. <br> <br>
			Calling getNext() on SLelement1 will return SLelement2, and calling
			getNext() on SLelement2 will return SLelement3. <br> <br>
			In this example, SLelement3 is not pointing to another SLelement so
			calling getNext() on SLelement3 will return Null. This is desirable
			since you will know that you’ve reached the end of all of the linked
			SLelements when one of them returns Null. <br> <br> Notice
			that there is no getPrev(). SLelement2 has no idea what element came
			before it. So, you CANNOT go backwards.

		</p>
	</div>


	<div class="section">

		<h1>
			<a id="DlElement">How does the DLelement&lt;E&gt; work?</a>
		</h1>
		<p>
			DLelement&lt;E&gt; stands for Doubly Linked Element, and is a type of
			container that has two pointers that point to other
			DLelement&lt;E&gt;. So a DLelement&lt;E&gt; “knows” who it’s pointing
			at, AND it knows who pointed at it. <br> <br> <img
				src="res/DLelement.png" style="max-width: 100%"> <br> <br>
		</p>
		In this example, calling getNext() on DLelement2 will return
		DLelement3. <br> <br> Calling getPrev() on DLelement2 will
		return DLelement1. <br> <br> In this example, DLelement3
		does not have a next pointer pointing to another DLelement so calling
		getNext() on DLelement3 will return Null, indicating the end of the
		linked elements. Since DLelement &lt;;E&gt;; have a getPrev() method,
		they can move forwards AND backwards through the linked elements.
	</div>


	<div class="section">

		<h1>
			<a id="TreeElement">How does the TreeElement&lt;E&gt; work?</a>
		</h1>
		<p>
			TreeElement&lt;E&gt; is another type of container that has two
			pointers that point to two child TreeElement&lt;E&gt;. By convention,
			these two pointers are called "left" and "right". <br> <img
				src="res/TreeElement.png" style="max-width: 100%"> <br>
			By convention, the “top” of the tree is called the root. <br> <br>
			Root has two pointers, so calling Root.getLeft() will return the
			TreeElement T1 and calling Root.getRight() will return the
			TreeElement T2. <br> <br> Note that there is no pointer
			from T1 or any other element back to its root.
	</div>

	<div class="section">

		<h1>
			<a id="TreeVsDLE">How does a TreeElement&lt;E&gt; differ from a
				DLelement&lt;E&gt;?<br>
			</a>
		</h1>
		<p>
			DLelement&lt;E&gt; also has two pointers, but one points to the
			previous element. TreeElement&lt;E&gt; does not point to the previous
			element, but points at two different children. <br> <br>
			DLelement&lt;E&gt; has a next and previous element, by convention, a
			TreeElement&lt;E&gt; has a right and left element. <br> <br>
			Generally a TreeElement&lt;E&gt; will be used in a recursive data
			structure and that data structure that will specify a particular
			relationship that all of the right elements have relative to it’s
			root and a different relationship that all left elements have
			relative to it’s root (a binary search tree, for example).
		</p>
	</div>


	<div class="section">
		<h1>
			<a id="ArrayElement">How does the ArrayElement&lt;E&gt; work?</a>
		</h1>
		<p>
			ArrayElement&lt;E&gt; is a building block for an array of elements. <br>
			<br> It has NO POINTERS to other objects. Unlike all of the
			other elements, it is designed to enable direct access to a
			particular element at a particular index. <br> <img
				src="res/ArrayElement.png" style="max-width: 100%"> <br>
			In this case once you’ve made an array of ArrayElements, you get
			access to the element by using the index, just like a normal Java
			array. <br> <br> For example myArray[2] would return
			ArrayElement2

		</p>
	</div>


	<div class="section">
		<h1>
			<a id="GraphElement">There is no GraphElement&lt;E&gt;. How is a
				graph represented?<br>
			</a>
		</h1>
		<p>
			In Bridges, graphs use an adjacency list representation and are built
			by using the Java HashMap&lt;String, SLelement&lt;E&gt;&gt;. <br>
			<br> In this case, the "key" is the identifier of the vertex,
			and the "value" is a set of linked SLelements representing the edges
			of the graph. <br> <br> In most graph representations, the
			key is the vertex, and the value assigned to it is the list of
			vertices that are connected to it <br> <br> Bridges is
			slightly different because the linked list mapped to the vertex
			starts with the vertex itself, and the subsequent links are the
			edges. <br> <br> <img src="res/SimpleGraph.png"> <br>
			For example, if we have vertices Vertex_A, Vertex_B, Vertex_C, and
			Vertex_D with Vertex_A connected to both Vertex_B and Vertex_C, and
			Vertex_C connected to Vertex_D, the classical representation would
			look as follows: <br> <br>
		<div class="graphExample">
			Vertex_A: Vertex_B--&gt;Vertex_C <br> Vertex_C: Vertex_D <br>
			<br>
		</div>
		Bridges representation would look like the following: <br>
		<div class="graphExample">
			<p>
				Vertex_A: Vertex_A--&gt;EdgeToB--&gt;EdgeToC <br> Vertex_C:
				Vertex_C--&gt;EdgeToD <br> <br>
		</div>
	</div>

	<div class="section">
		<h1>
			<a id="GraphCode">What is the code to get started making a graph?<br>
			</a>
		</h1>
		<ol>
			<li>Construct a BRIDGES object with an assignment number and
				your credentials. In this example, the assignment number is 61.<br>
				<br>
				<div class="codeExample">Bridges&lt;String&gt; bridges = new
					Bridges&lt;String&gt;(61, “yourNumericAPIKey”, “yourUserName”);</div> <br>
				<br>
			<li>Construct a HashMap to hold the adjacency list
				representation. of the graph <br> <br>
				<div class="codeExample">HashMap&lt;String,
					SLelement&lt;String&gt;&gt; graph = new HashMap&lt;String,
					SLelement&lt;String&gt;&gt;();</div> <br> <br>
			<li>Create some vertices.<br> <br>
				<div class="codeExample">
					SLelement v1 = new SLelement&lt;String&gt;("v1", "v1"); <br>
					SLelement v2 = new SLelement&lt;String&gt;("v2", "v2"); <br>
					SLelement v3 = new SLelement&lt;String&gt;("v3", "v3"); <br>
					SLelement v4 = new SLelement&lt;String&gt;("v4", "v4"); <br>
				</div> <br> <br>
			<li>Add those vertices to the HashMap. <br> <br>
				<div class="codeExample">
					graph.put(v1.getIdentifier(), v1); <br>
					graph.put(v2.getIdentifier(), v2); <br>
					graph.put(v3.getIdentifier(), v3); <br>
					graph.put(v4.getIdentifier(), v4);
				</div> <br> <br> Note what is happening here. The vertices we
				made in step three are being mapped to keys in the HashMap. Those
				vertices are the starting points of what will become a linked list
				of Edges.<br> <br>
			<li>Create some edges.<br> <br>
				<div class="codeExample">

					SLelement&lt;Edge&gt; edgeToV1 = new SLelement&lt;Edge&gt;("edge1",
					new Edge(0, v1.getIdentifier())); <br> SLelement&lt;Edge&gt;
					edgeToV2 = new SLelement&lt;Edge&gt;("edge2", new Edge(0,
					v2.getIdentifier())); <br> SLelement&lt;Edge&gt; edgeToV3 =
					new SLelement&lt;Edge&gt;("edge3", new Edge(0,
					v3.getIdentifier())); <br> SLelement&lt;Edge&gt; edgeToV4 =
					new SLelement&lt;Edge&gt;("edge4", new Edge(0,
					v4.getIdentifier())); <br> <br>
				</div> WARNING: It's best that you do not reuse an Edge once it's been
				added to a list.<br> See <a href="#GraphMistake">"Why are
					my graph edges connecting to vertices that I didn't assign?" </a> for
				further discussion<br> <br>
			<li>Build the linked list of edges. Let's say we want to make
				the following graph:<br> <br>
				<div class="graphExample">
					v1: v2 <br> v1: v3 <br> v1: v4 <br> <br>
				</div> Then we need the following code to add our SLelement&lt;Edge&gt;
				objects to the appropriate vertex<br> <br>

				<div class="codeComment">//add the edgeToV2 to v1's linked
					list</div>
				<div class="codeExample">
					v1.setNext(edgeToV2); <br> <br>
				</div>
				<div class="codeComment">
					//since v1 already has an edge, we do not want to call v1.setNext()
					<br> //we need to get v1's next pointer and set that to
					edgeToV3 <br>
				</div>
				<div class="codeExample">
					v1.getNext().setNext(edgeToV3); <br> <br>
				</div>
				<div class="codeComment">
					//since v1 already has two edges, we do not want to call
					v1.setNext() <br> //we need to get v1's next next pointer and
					set that to edgeToV4 <br> //this is just for illustration, in
					a real program, you'd need a more <br> //systematic of adding
					an edge to the end of a list <br>
				</div>

				<div class="codeExample">
					v1.getNext().getNext().setNext(edgeToV4); <br> <br>
				</div>
			<li>Call setDataStructure and pass the graph.<br> <br>
				<br>
				<div class="codeExample">bridges.setDataStructure(graph,
					"graphl");</div> <br> <br>
			<li>Call visualize<br> <br>
				<div class="codeExample">
					bridges.visualize(); <br> <br>
				</div> You should see something like this with the vertices connected<br>
				<br> <img src="res/FourVertexGraph.png">
		</ol>
	</div>


	<div class="section">
		<h1>
			<a id="GraphMistake">Why are my graph edges connecting to
				vertices that I didn't assign?</a>
		</h1>
		You've likely reused an SLelement&lt;Edge&gt; that setNext() had
		already been called on. <br> <br> For example, say we wanted
		to change the previous graph slightly so that there's an additional
		edge going from V2 to V3. <br>
		<div class="graphExample">
			v1: v2 <br> v1: v3 <br> v1: v4 <br> v2: v3 <br> <br>
		</div>
		It seems like we just need to add the following line of code and we'd
		be done: <br>
		<div class="codeExample">
			v2.setNext(edgeToV3); <br> <br>
		</div>
		But, you would get the following result: <br> <img
			src="res/MistakeGraph.png"> <br> Note that we did get an
		edge between V2 to V3, but we also got an edge between V2 and V4. But
		why? <br> <br> The trouble is coming from this line of code:
		<br>
		<div class="codeExample">
			v1.getNext().getNext().setNext(edgeToV4); <br> <br>
		</div>
		v1.getNext().getNext() will return v3 and we've set v3's next edge to
		v4. <br> <br> So when we call v2.setNext(edgeToV3), we're
		really passing the following:
		<div class="graphExample">edgeToV3--&gt;edgeToV4</div>
		<br> So we end up with:
		<div class="graphExample">v2: v2--&gt;edgeToV3--&gt;edgeToV4</div>
		<br> <br> Instead of this, which is what we wanted:
		<div class="graphExample">v2: v2--&gt;edgeToV3</div>
		<br> <br> You can prevent this by not re-using your edges.
		For example, this will map v2 to a new edge: <br> <br>
		<div class="codeExample">
			v2.setNext(new SLelement&lt;Edge&gt;("newEdge", new Edge(0,
			v3.getIdentifier()))); <br> <br>
		</div>
		You should get the following result now: <br> <img
			src="res/CorrectGraph.png">
	</div>

	<div class="section">
		<h1>
			<a id="GraphNotVisible">I've connected my graph edges, but the
				visualization doesn't show any nodes.<br>
			</a>
		</h1>
		Likely you've made a mistake in the hashmap that you're are passing to
		setDataStructure. You may have inadvertently added an edge to an
		element that does not exist in that hashmap by creating a NEW element
		instead of getting the identifier for the element from the hashmap.
		<br><br>
		Carefully check your HashMap.

	</div>

	<div class="section">
		<h1>
			<a id="BasicVisualize">How do I get Bridges to visualize?</a>
		</h1>
		<p>
			At a minimum, Bridges needs four things to provide a visualization. <br>
			<br>
		<ol>
			<li>Construct a BRIDGES object with an assignment number and
				your credentials. In this example, the assignment number is 61.<br>
				<br>
				<div class="codeExample">Bridges&lt;String&gt; bridges = new
					Bridges&lt;String&gt;(61, “yourNumericAPIKey”, “yourUserName”);</div> <br>
				<br>
			<li>Construct one of the element objects<br> <br>
				<div class="codeExample">SLelement&lt;String&gt; sle = new
					SLelement&lt;String&gt;(“ABC”, “XYZ”);</div> <br> <br>
			<li>Call setDataStructure() from your Bridges object and pass it
				the element and the type of structure<br> <br>
				<div class="codeExample">bridges.setDataStructure(sle,
					“llist”);</div> <br> <br>
			<li>Call complete() or visualize() from your Bridges object. The
				URL will populate in the console window<br> <br>
				<div class="codeExample">bridges.visualize();</div> <br> <br>
				Or <br> <br>
				<div class="codeExample">bridges.complete();</div> <br> <br>
		</ol>
	</div>


	<div class="section">
		<h1>
			<a id="SetDataStructure">What do I pass to setDataStructure()?</a>
		</h1>
		setDataStructure() needs two things:
		<ol>
			<li>A subclass of Element or a HashMap of SLelements (for
				graphs)<br> <br>
			<li>The type of visualization:
				<ul>
					<li>"graphl"
					<li>"stack"
					<li>"queue"
					<li>"tree"
					<li>"llist"
					<li>"dlist"
				</ul>
		</ol>
		<br> Normally, you would pass the first element of the list, so
		that the whole list is visualized. There is nothing to prevent you
		from passing any element of the list, but you will only see that
		element and it's children when the list is visualized. <br> <br>
		For example, say I have three SLelements linked to together and pass
		it the first element. I should see the following <br> <img
			src="res/ThreeLinks.png"> <br> <br> But if I pass it
		the second SLelement instead, I would see this in the visualization: <img
			src="res/TwoLinks.png"> <br>
	</div>


	<div class="section">
		<h1>
			<a id="Refresh">How do I refresh the visualization?</a>
		</h1>
		<p>
			If your program has made changes to your data structure and you would
			like to see the new visualization, call visualize() from your Bridges
			object when you want to see the new visualization. <br> <br>
		<div class="codeExample">bridges.visualize();</div>
		<br> <br> The new URL will populate in the console. The new
		assignment number will be the prior assignment incremented by .01.
	</div>


	<div class="section">
		<h1>
			<a id="VisualizeTiming">When should I call visualize()?</a>
		</h1>
		<p>
			Generally, this will be dictated by the project that you are working
			on. <br> <br> If the project only requires the
			visualization of the finished structure, then it makes sense to only
			call visualize() once, after you’ve linked together your elements. <br>
			<br> If the project requires showing some intermediate steps,
			you can call visualize() multiple times and it will increment your
			assignment number by .01, and provide you a new URL in the console
			window.
		</p>
	</div>


	<div class="section">
		<h1>
			<a id="TextVisualization">How do I change the text field on the
				Visualization?</a>
		</h1>
		<p>
			All Elements have a setLabel(String s) method. Setting this will
			change the text that appears on screen. <br> <br> For
			example, if sle is an SLelement:
		<div class="codeExample">sle.setLabel(“This is a new label”);</div>
	</div>


	<div class="section">
		<h1>
			<a id="NodeColor">How do I change the node color, size, or
				opacity on the Visualization?<br>
			</a>
		</h1>
		<p>
			Each element has a getVisualizer() method. This will return an
			ElementVisualizer object. <br> <br> The ElementVisualizer
			is the object that controls how the visualization looks. <br> <br>
			The ElementVisualizer can be changed using the setColor(),
			setOpacity(), setShape(), and setSize() methods. <br> <br>
			The easiest way to change the ElementVisualizer is to chain together
			methods. For example if sle is an SLelement:
		<div class="codeComment">//change the node color to blue</div>
		<div class="codeExample">sle.getVisualizer().setColor(“blue”);</div>
		<br> <br>
		<div class="codeComment">//make the node INVISIBLE!!!</div>
		<div class="codeExample">sle.getVisualizer().setOpacity(0);</div>
		<br> <br>
		<div class="codeComment">//make the node half transparent</div>
		<div class="codeExample">sle.getVisualizer().setOpacity(.5);</div>
		<br> <br>
		<div class="codeComment">//make the node HUGE!!!</div>
		<div class="codeExample">sle.getVisualizer().setSize(40);</div>
		<br> <br>
		<div class="codeComment">//make the node square shaped instead
			of circular</div>
		<div class="codeExample">sle.getVisualizer().setShape("square");</div>


		<br> <br> Generally, there is no need to assign the
		ElementVisualizer that comes back from the getVisualizer() method to a
		new object.
	</div>


	<div class="section">
		<h1>
			<a id="Projects">How do I start a new visualization without
				overwriting the old one?</a>
		</h1>
		<p>
			You can keep different projects separated by changing the assignment
			number. <br> <br> Normally, you will set the assignment
			number at the beginning of your project when you construct the
			Bridges object. <br> <br>
		<div class="codeExample">Bridges&lt;String&gt; bridges = new
			Bridges&lt;String&gt;(61, “yourNumericAPIKey”, “yourUserName”);</div>
		<br> <br> If you've already constructed a Bridges object in
		your program, and would like to store it as a separate project, you
		can call setAssignment() from the Bridges object and pass it a new
		assignment number. <br> <br>
		<div class="codeExample">bridges.setAssignment(12);</div>
		<br> <br> This will set the assignment number to 12. All
		changes to the data structure will take place on assignment 12 instead
		of assignment 61.
	</div>

</body>
</html>